<!-- docs/index.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Authority Before Execution - Execution Inspection</title>
  <meta name="description" content="Read-only inspection site for execution-time authority enforcement. Repro steps, invariant, artifacts, and Opik trace boundary." />
  <link rel="stylesheet" href="./styles.css" />
</head>

<body>
  <a class="skip" href="#main">Skip to content</a>

  <header class="header">
    <div class="wrap header__inner">
      <div class="brand">
        <div class="brand__name">Authority Before Execution</div>
        <div class="brand__tag">
          Execution-time authority enforcement, verified at the commit boundary.
        </div>
      </div>

      <div class="header__links">
        <a class="link" href="https://github.com/qstackfield/authority-before-execution" target="_blank" rel="noreferrer">Repository</a>
        <a class="link" href="#reproduce">Reproduce</a>
        <a class="link" href="#evidence">Evidence</a>
        <a class="link" href="#opik">Opik</a>
      </div>
    </div>
  </header>

  <main id="main" class="wrap">
    <section class="lead" aria-label="Executive summary">
      <h1>Execution Inspection</h1>
      <p class="lede">
        This site is intentionally static. The proof is produced when you run the demo:
        structured allow/deny decisions, immutable JSON artifacts written to disk, and Opik traces emitted
        at the execution boundary.
      </p>

      <div class="meta">
        <div class="meta__row">
          <div class="meta__k">Mode</div>
          <div class="meta__v">Static inspection site</div>
        </div>
        <div class="meta__row">
          <div class="meta__k">Purpose</div>
          <div class="meta__v">Judge verification (reproducible, inspectable)</div>
        </div>
        <div class="meta__row">
          <div class="meta__k">Backend</div>
          <div class="meta__v">Not required for the site</div>
        </div>
      </div>
    </section>

    <hr class="sep" />

    <section id="invariant" aria-label="Invariant">
      <h2>Invariant</h2>
      <p class="sub">
        The system is built around one execution rule. If it does not hold, the design fails.
      </p>

      <div class="invariant">
        <div class="invariant__top">
          <div class="pill">Invariant ID: <span class="mono">ABE-EXEC-001</span></div>
          <div class="pill">Enforcement point: <span class="mono">core/executor.py</span></div>
          <div class="pill">Fail mode: <span class="mono">fail-closed</span></div>
        </div>

        <div class="invariant__statement">
          If explicit authority is not present, valid, and in scope at execution time, the state transition must not occur.
        </div>

        <div class="invariant__snippet mono">
          No authority at execution time → no state change
        </div>
      </div>
    </section>

    <hr class="sep" />

    <section id="enforcement" aria-label="Enforcement summary">
      <h2>Enforcement summary</h2>
      <ul class="bullets">
        <li><strong>Where execution happens:</strong> a single commit point (<span class="mono">core/executor.py</span>).</li>
        <li><strong>What is checked:</strong> authority presence, scope, and expiry at runtime.</li>
        <li><strong>When it is checked:</strong> immediately before state change (not after the fact).</li>
        <li><strong>On failure:</strong> execution is blocked deterministically; the outcome is returned as a structured result.</li>
      </ul>
    </section>

    <hr class="sep" />

    <section id="reproduce" aria-label="Reproduce">
      <h2>Reproduce</h2>
      <p class="sub">
        Judges should not have to trust a narrative. They should be able to rerun the proof and inspect outputs.
      </p>

      <div class="callout">
        <div class="callout__title">Run the demo</div>
        <pre class="code mono"><code>python3 -m demo.run_demo</code></pre>

        <div class="callout__grid">
          <div class="kv">
            <div class="kv__k">Expected outcomes</div>
            <div class="kv__v">
              missing authority → deny<br />
              valid scoped authority → allow<br />
              out of scope → deny<br />
              expired authority → deny
            </div>
          </div>

          <div class="kv">
            <div class="kv__k">Local artifacts written</div>
            <div class="kv__v">
              <span class="mono">docs/artifacts/*.json</span><br />
              (immutable JSON per attempt)
            </div>
          </div>

          <div class="kv">
            <div class="kv__k">Trace boundary</div>
            <div class="kv__v">
              <span class="mono">execution.commit</span><br />
              (captured via Opik)
            </div>
          </div>
        </div>

        <p class="note">
          The artifacts are generated at demo time on the machine that runs the command. They are intentionally not committed
          to GitHub to avoid shipping stale evidence.
        </p>
      </div>
    </section>

    <hr class="sep" />

    <section id="evidence" aria-label="Evidence">
      <h2>Evidence</h2>
      <p class="sub">
        What makes this “real” is not the website. It’s the runtime boundary: code enforcement + deterministic outcomes + artifacts + traces.
      </p>

      <div class="two">
        <div class="panel">
          <div class="panel__title">What to inspect in code</div>
          <ul class="bullets">
            <li><span class="mono">core/executor.py</span> - the only commit point; fail-closed enforcement.</li>
            <li><span class="mono">core/authority_gate.py</span> - authority validity rules (missing / scope / expiry).</li>
            <li><span class="mono">core/artifact_exporter.py</span> - immutable JSON evidence written at the boundary.</li>
            <li><span class="mono">core/evaluation.py</span> - decision-level aggregation (deny breakdown, allow rate).</li>
          </ul>
        </div>

        <div class="panel">
          <div class="panel__title">What to inspect after running</div>
          <ul class="bullets">
            <li>Console output: four attempts with explicit reasons and a final invariant verdict.</li>
            <li>Disk: <span class="mono">docs/artifacts/*.json</span> produced during the run.</li>
            <li>Opik: a trace for the boundary call <span class="mono">execution.commit</span>.</li>
          </ul>
        </div>
      </div>

      <details class="details">
        <summary>Example console output format (for reference)</summary>
        <pre class="code mono"><code>python3 -m demo.run_demo

Authority Before Execution — Execution Boundary Proof
run_id            : &lt;uuid&gt;
started_at        : &lt;utc timestamp&gt;
invariant_id      : ABE-EXEC-001
invariant         : If explicit authority is not present, valid, and in scope at execution time, the state transition must not occur.

1) Attempt without authority
outcome           : BLOCKED
deny_reason       : missing_authority

2) Attempt with valid scoped authority
outcome           : PERMITTED

3) Attempt out of scope
outcome           : BLOCKED
deny_reason       : scope_violation

4) Attempt after expiration
outcome           : BLOCKED
deny_reason       : expired_authority

Invariant ABE-EXEC-001: HELD</code></pre>
        <p class="note">
          This is the format. Your run will include real timestamps, run_id, and locally written artifacts.
        </p>
      </details>

      <details class="details">
        <summary>Example artifact schema (immutable JSON record)</summary>
        <pre class="code mono"><code>{
  "decision_id": "demo-deploy-001",
  "timestamp": "&lt;utc timestamp&gt;",
  "execution_allowed": false,
  "deny_reason": "missing_authority",
  "authority_overbroad": false,
  "action": "deploy_model",
  "params": { "model": "gpt-4.1", "environment": "production" },
  "authority": null
}</code></pre>
        <p class="note">
          Artifacts are written by <span class="mono">core/artifact_exporter.py</span> at execution time.
        </p>
      </details>
    </section>

    <hr class="sep" />

    <section id="opik" aria-label="Opik">
      <h2>Opik</h2>
      <p class="sub">
        Opik is used to trace the execution boundary and support evaluation runs. The important claim is not “we log traces” —
        it’s that traces capture enforcement where state change would occur.
      </p>

      <div class="panel">
        <div class="panel__title">What Opik proves here</div>
        <ul class="bullets">
          <li>Boundary call is traced at <span class="mono">execution.commit</span>.</li>
          <li>Inputs and structured outputs are captured consistently (inspectable, stable).</li>
          <li>Evaluation summaries can be compared across runs and conditions.</li>
        </ul>
      </div>
    </section>

    <hr class="sep" />

    <section id="non-goals" aria-label="Non-goals">
      <h2>Non-goals (intentional)</h2>
      <p class="sub">
        This repo is a vertical slice to prove an invariant at the execution boundary, not a full governance platform.
      </p>

      <ul class="cols">
        <li>RBAC / identity systems</li>
        <li>Approval workflow UIs</li>
        <li>Policy DSLs or rule engines</li>
        <li>Credential/key management</li>
        <li>Multi-agent orchestration</li>
        <li>Production deployment scaffolding</li>
      </ul>
    </section>

    <footer class="footer">
      <div class="footer__row">
        <div class="footer__k">Repository</div>
        <div class="footer__v">
          <a class="link" href="https://github.com/qstackfield/authority-before-execution" target="_blank" rel="noreferrer">
            github.com/qstackfield/authority-before-execution
          </a>
        </div>
      </div>
      <div class="footer__row">
        <div class="footer__k">Primary verification</div>
        <div class="footer__v"><span class="mono">python3 -m demo.run_demo</span></div>
      </div>
    </footer>
  </main>
</body>
</html>
